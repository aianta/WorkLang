/*
 * generated by Xtext 2.12.0
 */
package org.worklang.scoping

import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EObject
import java.util.ArrayList
import org.worklang.work.ReferenceState
import org.eclipse.xtext.EcoreUtil2
import org.worklang.work.FieldDefinition
import org.eclipse.xtext.scoping.Scopes
import org.worklang.work.StateMapping
import org.worklang.work.Model
import org.worklang.work.TransitionMapping

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class WorkScopeProvider extends AbstractWorkScopeProvider {

	override getScope(EObject context, EReference reference){
		
		println("getting scope for context " + context + " with reference " + reference)
		
		
		//Resolve references to states in other fields in the same work file
		if (reference.name.equals("refState")){
			if (context instanceof org.worklang.work.ReferenceState){
				val scopeIDList = new ArrayList
				println("custom scoping rule")
				
				var refState = context as ReferenceState
				println("refState=" + refState)
				
				
				//Name of target field
				val targetField = refState.foreignField
				println("targetSpace=" + targetField)
				println("target space name: "+ targetField.name)
				
				
				/* Iterate through all fields in the current work file.
				 * Find target field.
				 * Use target field's definitionspace as scope for resolving the StateID
				 */
				
				val root = EcoreUtil2.getRootContainer(context)	
				
				
				
				//Target Field
				val targetFieldInstance = root.eContents.filter[rootElement| 
					rootElement.eClass.instanceClass.equals(org.worklang.work.FieldDefinition)
				].findFirst[ele|
					(ele as FieldDefinition).name.equals(targetField.name)
				]
				
				println("targetFieldInstance=" + targetFieldInstance)
				println("targetFieldInstance name: "+ (targetFieldInstance as FieldDefinition).name)
				
				var field = targetFieldInstance as FieldDefinition
				
				field.definitionSpace.states.forEach[stateDefinition|
					println("adding State Definition " + stateDefinition)
					scopeIDList.add(stateDefinition)
				]
				
				
				
				return Scopes.scopeFor(scopeIDList)
			}else{
				return super.getScope(context,reference)
			}
		}else if (reference.name.equals("foreignState")){
			if (context instanceof StateMapping){
				val scopeIDList = new ArrayList
				var mapping = context as StateMapping
				
				val mappedField = mapping.field.name
				
				println("mappedField ->"+ mappedField)
				
				val root = EcoreUtil2.getRootContainer(context)	
				
				val model = root as Model
				
				//All Field
				model.fields.forEach[field|
					println("field -> " + field.name)	
				]
				
				//Target Field
				val targetFieldInstance = model.fields.findFirst[field|
					field.name === mappedField
				]
				
				println("targetFieldInstance=" + targetFieldInstance)
				println("targetFieldInstance name: "+ (targetFieldInstance as FieldDefinition).name)
				
				
				
				targetFieldInstance.definitionSpace.states.forEach[stateDefinition|
					println("adding State Definition " + stateDefinition)
					scopeIDList.add(stateDefinition)
				]
				
				return Scopes.scopeFor(scopeIDList)
				
			}else{
				super.getScope(context, reference)
			
			}
			
		}else if (reference.name.equals("foreignTransition")){
				if (context instanceof TransitionMapping){
					val scopeIDList = new ArrayList
					var mapping = context as TransitionMapping
					
					val mappedField = mapping.field.name
					
					println("mappedField ->"+ mappedField)
					
					val root = EcoreUtil2.getRootContainer(context)	
					
					val model = root as Model
					
					//All Field
					model.fields.forEach[field|
						println("field -> " + field.name)	
					]
					
					//Target Field
					val targetFieldInstance = model.fields.findFirst[field|
						field.name === mappedField
					]
					
					println("targetFieldInstance=" + targetFieldInstance)
					println("targetFieldInstance name: "+ (targetFieldInstance as FieldDefinition).name)
					
					
					
					targetFieldInstance.definitionSpace.transitions.forEach[transitionDefinition|
						println("adding State Definition " + transitionDefinition)
						scopeIDList.add(transitionDefinition)
					]
					
					return Scopes.scopeFor(scopeIDList)
					
					
				}else{
					return super.getScope(context,reference)
				}
			
				
		}else{
			return super.getScope(context,reference)
		}
			
	}

}
