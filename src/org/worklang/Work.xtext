/* 
 * 	Copyright 2018 Alexandru Ianta
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * 	Unless required by applicable law or agreed to in writing, software
 *	distributed under the License is distributed on an "AS IS" BASIS,
 *	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *	See the License for the specific language governing permissions and
 *	limitations under the License.
 * 
 */

grammar org.worklang.Work with org.eclipse.xtext.common.Terminals

generate work "http://www.worklang.org/Work"


Model:
	fields += FieldDefinition*
	//experts += ExpertDefinition*
	//practitioners += Practitioner*
	//instructions += Instruction*
;

/* Executable Structure
 * Below are the grammar rules for defining execution requests for the work interpreter.
 */
//Instruction:
//	objectType = 'instruction' space = [Space] transition = [TransitionID]
//;



//Practitioner:
//	practitionerDef = 'practitioner'
//	user = User
//	'{'
//	knowledgeDef = KnowledgeDefinition?
//	skillsDef = SkillsDefinition?
//	'}'
//;

//ExpertDefinition:
//	expertDef = 'expert' user = User
//	'{'
//	domainDef = DomainDefinition?
//	knowledgeDef = KnowledgeDefinition?
//	skillsDef = SkillsDefinition?
//	'hourlyRate'
//	'$' rate =  INT
//	'}'
//;

//User:
//	name = ID
//;
	

//DomainDefinition:
//	domain = 'domain'
//	'{'
//		domainAreas += ReferenceField*
//	'}'
//;

//KnowledgeDefinition:
//	knowledgeDef = 'knowledge''{'
//		knowledge += ReferenceState*
//	'}'
//;

//SkillsDefinition:
//	skillsDef = 'skills''{'
//		skills += ReferenceTransition*
//	'}'
//;


//FieldDefinition:
//	field = Field
//	space = Space
//	extends=(ExtendsDefinition)? 
//	'{'
//	(conceptualspace = Namespace)?
//	(referencespace = Referencespace)?
//	(mappedspace = Mapspace)?
//	(instancespace = Instancespace)?
//	'}'	
//;

FieldDefinition:
	'field'
	name = ID
	'{'
	(definitionSpace = DefinitionSpace)?
	(referenceSpace = ReferenceSpace)?
	(mapSpace = MapSpace)?
	(instanceSpace = InstanceSpace)?
	'}'
;

//Space:
//	name = ID
//;

MapSpace:
	{MapSpace} 'mappings''{'
	mappedStates += StateMapping*
	mappedTransitions += TransitionMapping*
	'}'
;

StateMapping:
	'state' foreignState=[StateDefinition] 'from' field = [FieldDefinition] 'to' localState=[StateDefinition]
;

TransitionMapping:
	'transition' foreignTransition=[TransitionID] 'from' field = [FieldDefinition] 'to' localTransition=[TransitionID]
;

//Namespace:
//	spaceType = Definitions
//	'{'
//	states += StateObjectDefinition*
//	transitions += TransitionObjectDefinition*
//	'}'
//;

DefinitionSpace:
	{DefinitionSpace} 'definitions'
	'{'
	states += StateDefinition*
	transitions += TransitionDefinition*
	'}'
;

StateDefinition:
	PrimitiveStateDefinition|CompoundStateDefinition
;

PrimitiveStateDefinition:
	type = 'primitive'
	'state'
	name = ID
;

CompoundStateDefinition:
	type = 'compound'
	'state'
	name = ID
	composition= WithStatesDefinition
;

TransitionDefinition:
	PrimitiveTransitionDefinition|CompoundTransitionDefinition
;

PrimitiveTransitionDefinition:
	type = 'primitive'
	'transition'
	name = ID
	(in = InputDefinition)?
	out = OutputDefinition
;

CompoundTransitionDefinition:
	type = 'compound'
	'transition'
	name = ID
	(in = InputDefinition)?
	out = OutputDefinition
	composition = WithTransitionsDefinition
;

//TransitionDefinition:
//	object = Transition transition = TransitionID (in = InputDefinition)? out = OutputDefinition (composition = WithTransitionsDefinition)?
//;



//Referencespace:
//	spaceType = References
//	'{'
//	refFields += ReferenceField*
//	refStates += ReferenceState*
//	refTransition += ReferenceTransition*
//	'}'
//;

ReferenceSpace:
	{ReferenceSpace} 'references'
	'{'
	refStates += ReferenceState*
	refTransitions += ReferenceTransition*
	'}'
;

ReferenceTransition:
	'transition'
	refTransition = [TransitionDefinition]
	'from'
	foreignField = [FieldDefinition]
	
;

ReferenceState:
	'state'
 	refState = [StateDefinition]
	'from'
	foreignField = [FieldDefinition] 
;

//
//Instancespace:
//	spaceType  = Instances
//	'{'
//		instances += Instance*
//	'}'
//;

InstanceSpace:
	{InstanceSpace} 'instances'
	'{'
	instances += Instance*
	'}'
;

//ReferenceField:
//	ref = Field 
//	space = Space
//;

//StateObjectDefinition:
//	(type = Primitive| type = Compound)
//	state = StateDefinition 
//;
//
//TransitionObjectDefinition:
//	(type = Primitive| type = Compound)
//	transition = TransitionDefinition
//;

//PrimitiveStateDefinition:
//	object = State id = StateID 
//;
//
//CompoundStateDefinition:
//	object = State state = StateID (compoundStateDef= WithStatesDefinition)?
//;

//StateDefinition:
//	object = State state = StateID (withDefinition= WithStatesDefinition)?
//;


//StateID:
//	 name = ID
//;

WithStatesDefinition:
	'with'
	'{'
	predicate= Predicate
	'}'
;

WithTransitionsDefinition:
	'with'
	'{'
	transitions = TransitionalExpression
	'}'
;





//TransitionID:
//	name = ID
//;



//FromFieldDefinition:
//	from = From
//	refSpace = [Space]
//;


InputDefinition:
	{InputDefinition} 'input' inputState += [StateDefinition]*
;

OutputDefinition:
	'output' outputState = [StateDefinition]
;

//ExtendsDefinition:
//	type = Extends
//	namespaces += [Space]+	
//;
//
//
//Primitive:
//	'primitive' 
//;
//
//Compound:
//	'compound'
//;
//
//Field:
//	'field'
//;
//
//State:
//	'state'
//;
//
//
//Transition:
//	'transition'
//;
//
//Definitions:
//	'definitions'
//;
//
//References:
//	'references'
//;
//
//Instances:
//	'instances'
//;
//
//Input:
//	'input'
//;
//
//Output:
//	'output'
//;
//
//From:
//	'from'
//;
//
//With:
//	'with'
//;
//
//Extends:
//	'extends'
//;
//
//NotOp:
//	'NOT'
//;
//
//AndOp:
//	'AND'
//;
//
//OrOp:
//	'OR'
//;
//
//Set:
//	'set'
//;
//
//To:
//	'to'
//;
//
//Use:
//	'use'
//;
//
//
//Count:
//	INT
//;

Instance:
	'instance' 
	(transitionDeclaration = TransitionDeclaration| stateDeclaration = StateDeclaration) 
	name = STRING 
	(state = StateInstance | transition = TransitionInstance)
;

TransitionDeclaration:
	'transition' transition = [TransitionID]
;

StateDeclaration:
	'state' state = [StateDefinition]
;

TransitionInstance:
	host = STRING
	port = INT
	(path = STRING)?
;

StateInstance:
	 
	'{'
		members += (SetStatement| UseDefinition| Instance)+
	'}'
			
;

UseDefinition:
	'use' predefinedValue = [Instance] 
;

SetStatement:
	'set' variable = [StateDefinition] toDef = ToDefinition
;

ToDefinition:
	'to' value = STRING
;

//State Composition Expression Rules
Predicate:
	(negation?='NOT')? expression = BinaryExpression
;

BinaryExpression:
	TerminalBinaryExpression ({Operation.left=current}
		op= ('AND'|'OR') right = TerminalBinaryExpression)*
;

TerminalBinaryExpression returns BinaryExpression:
	'(' Predicate ')'|
	 {StateDefinition} instance = [StateDefinition]|
	 {StateDefinition}(list ?= 'setOf' value = [StateDefinition])
;


//Transition Composition Expression Rules
TransitionalExpression:
	TerminalTransitionalExpression ({Operation.left=current}
		op= 'THEN' right = TerminalTransitionalExpression)*	
;

TerminalTransitionalExpression returns TransitionalExpression:
	'(' TransitionalExpression ')'|
	{TransitionID} value = [TransitionID]
;




