/* 
 * 	Copyright 2018 Alexandru Ianta
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * 	Unless required by applicable law or agreed to in writing, software
 *	distributed under the License is distributed on an "AS IS" BASIS,
 *	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *	See the License for the specific language governing permissions and
 *	limitations under the License.
 * 
 */

grammar org.worklang.Work with org.eclipse.xtext.common.Terminals

import 'http://www.eclipse.org/emf/2002/Ecore' as ecore

generate work "http://www.worklang.org/Work"


WorkNet:
	{WorkNet}
	name = '@'
	':'
	types += FieldType*
;

Field:
	'{'
	applicationSpace = ApplicationSpace
//	(definitionSpace = DefinitionSpace)?
//	(referenceSpace = ReferenceSpace)?
//	(mapSpace = MapSpace)?
//	(instanceSpace = InstanceSpace)?
	'}'
;

ApplicationSpace:
	{ApplicationSpace} 'application'':'
	applications += ApplicationType*
;

Application:
	'{'
	componentSpace = ComponentSpace
	'}'
;

ComponentSpace:
	{ComponentSpace} 'components'':'
	components += ComponentType*	
;

Component:
	'{'
	objectSpace = ObjectSpace
	'}'
;

ObjectSpace:
	{ObjectSpace} 'objects:'
	objects += ObjectType*
;

Object:
	'{'
	stateSpace = StateSpace
	'}'
;

StateSpace:
	{StateSpace} 'states'':'
	states += StateType*
;

State:
	'{'
	identitySpace = IdentitySpace
	'}'
;


IdentitySpace:
	{IdentitySpace} 'identities'':'
	identities += IdentityType*
;

Identity:
	'{'
	primitives += WorklangPrimitiveType+
	'}'
;


WorklangString:
	name = STRING
;

WorklangInteger:
	name = INT
;

WorklangDouble:
	name = DOUBLE
;

WorklangBoolean:
	name = BOOLEAN
;

terminal DOUBLE returns ecore::EDouble:
	('-')?INT'.'INT
;

terminal PRIMITIVE_TYPES:
	'string'|'boolean'|'integer'
;

terminal SIGN:
	'++'|'--'
;

Index:
	sign = SIGN id = INT
;

BOOLEAN:
	TRUE|FALSE
;

terminal TRUE returns ecore::EBoolean:
	'TRUE'
;

terminal FALSE returns ecore::EBoolean:
	'FALSE'
;

Identifier:
	PrimitiveIdentifier|UserIdentifier
;

PrimitiveIdentifier:
	index = Index term = ('String'|'Integer'|'Double'|'Boolean')
;

UserIdentifier:
	index = Index term = ID
;

Type:
	Definition|
	Reference
;

FieldType:
	FieldDefinition|Reference
;

ApplicationType:
	ApplicationDefinition|Reference
;

ComponentType:
	ComponentDefinition|Reference
;

ObjectType:
	ObjectDefinition|Reference
;

StateType:
	StateDefinition|Reference
;

IdentityType:
	IdentityDefinition|Reference
;

WorklangPrimitiveType:
	WorklangPrimitiveDefinition|Reference
;



Definition:
	name = Identifier 
	worknetDefinition = (
		FieldDefinition|
		ApplicationDefinition|
		ComponentDefinition|
		ObjectDefinition|
		StateDefinition|
		IdentityDefinition|
		WorklangPrimitiveDefinition
	)
;

FieldDefinition:
	name = UserIdentifier 
	worknetDefinition = Field
;

ApplicationDefinition:
	name = UserIdentifier 
	worknetDefinition = Application
;

ComponentDefinition:
	name = UserIdentifier 
	worknetDefinition = Component
;

ObjectDefinition:
	name = UserIdentifier 
	worknetDefinition = Object
;

StateDefinition:
	name = UserIdentifier 
	worknetDefinition = State
;

IdentityDefinition:
	name = UserIdentifier 
	worknetDefinition = Identity
;

WorklangPrimitiveDefinition:
	name = PrimitiveIdentifier 
	worknetDefinition = WorklangPrimitive
;

WorklangPrimitive:
	primitiveValue = (
		WorklangString|
		WorklangInteger|
		WorklangDouble|
		WorklangBoolean
	)
;

WorkNetDefinition:
	Field|Application|Component|Object|State|Identity|WorklangPrimitive
;


Reference:
	AbstractReference|DefinedReference|CompleteReference
;

AbstractReference:
	QuantifiedAbstractReference|VagueReference
;

QuantifiedAbstractReference:
	level = Level name = ID 
;

VagueReference:
	name = ID
;

CompleteReference:
	'('definition = DefinedReference concept = VagueReference')'
;

DefinedReference:
	'['name = Address']'
;

Address:
	root = AddressRoot
	address += AddressSegment+
;

AddressRoot:
	value = AbstractReference|{AddressRoot} '@'
;

AddressSegment:
	'.' (DefinedAddressSegment|ConceptualAddressSegment|CompleteAddressSegment)
;

DefinedAddressSegment:
	index = INT
;

ConceptualAddressSegment:
	sign = SIGN
;

CompleteAddressSegment:
	sign = SIGN index = INT
;



Level:
	'identity'|'state'|'object'|'component'|'application'|'field'
;




MapSpace:
	{MapSpace} 'mappings''{'
	mappedStates += StateMapping*
	mappedTransitions += TransitionMapping*
	'}'
;

StateMapping:
	'state' foreignState=[StateDefinition] 'from' field = [Field] 'to' localState=[StateDefinition]
;

TransitionMapping:
	'transition' foreignTransition=[TransitionDefinition] 'from' field = [Field] 'to' localTransition=[TransitionDefinition]
;


DefinitionSpace:
	{DefinitionSpace} 'definitions'
	'{'
	//states += StateDefinition*
	transitions += TransitionDefinition*
	'}'
;

//StateDefinition:
//	PrimitiveStateDefinition|CompoundStateDefinition
//;

PrimitiveStateDefinition:
	type = 'primitive'
	'state'
	name = ID
	'{'
	terms = Terms
	'}'
;

CompoundStateDefinition:
	type = 'compound'
	'state'
	name = ID
	'('
	arguments += Argument*
	')'
	'{'
	terms = Terms
	'}'
;

CompositionArgument:
	SingularCompositionArgument|PluralCompositionArgument
;

SingularCompositionArgument:
	state = [StateDefinition]
;

PluralCompositionArgument:
	'[' (count = INT '|')? state = [StateDefinition] ']'
;

TransitionDefinition:
	PrimitiveTransitionDefinition|CompoundTransitionDefinition
;

PrimitiveTransitionDefinition:
	type = 'primitive'
	'transition'
	name = ID
	(in = InputDefinition)?
	out = OutputDefinition
;

CompoundTransitionDefinition:
	type = 'compound'
	'transition'
	name = ID
	(in = InputDefinition)?
	out = OutputDefinition
	composition = TransitionComposition
;

ReferenceSpace:
	{ReferenceSpace} 'references'
	'{'
	refStates += ReferenceState*
	refTransitions += ReferenceTransition*
	'}'
;

ReferenceTransition:
	'transition'
	refTransition = [TransitionDefinition]
	'from'
	foreignField = [Field]
	
;

ReferenceState:
	'state'
 	refState = [StateDefinition]
	'from'
	foreignField = [Field] 
;


InstanceSpace:
	{InstanceSpace} 'instances'
	'{'
	instances += Instance*
	'}'
;


Terms:
	{Terms} 
	elements += Term*
;

Conditions:
	{Conditions}
	wffs+=Formula*
;


InputDefinition:
	{InputDefinition} 'INPUT' inputState += [StateDefinition]*
;

OutputDefinition:
	'OUTPUT' (outputState = [StateDefinition]|outputValue = PRIMITIVE_TYPES)
;

Instance:
	'instance' 
	(transitionDeclaration = TransitionDeclaration| stateDeclaration = StateDeclaration)
	isCollectionElement ?= ('collectionElement')? 
	(name = STRING| name = COLLECTION_ELEMENT_NAME) 
	(state = StateInstance | transition = TransitionInstance| /*compoundTransition = CompoundTransitionInstance|*/ collection = CollectionInstance)
;

TransitionDeclaration:
	'transition' transition = [TransitionDefinition]
;

StateDeclaration:
	'state' state = [StateDefinition]
;

TransitionInstance:
	host = STRING
	(port = INT)?
	(path = STRING)?
	supportCollections?= ('hasCollectionSupport')?
	blind?=('blind')?
;

StateInstance:
	':'
		conditions = Conditions
			
;

CollectionInstance:
	{CollectionInstance} '['
		elements += [Instance|COLLECTION_ELEMENT_NAME]*
	']'
;

terminal COLLECTION_ELEMENT_NAME:
	('#' ID '#' INT '#' ID?)
;

UseDefinition:
	('use' predefinedValue = [Instance|STRING])|('use' predefinedValue = [Instance|COLLECTION_ELEMENT_NAME]) 
;

SetStatement:
	'set' variable = [StateDefinition] toDef = ToDefinition
;

ToDefinition:
	'to' value = STRING
;

//State Composition Expression Rules
//Predicate:
//	(negation?='NOT')? expression = BinaryExpression
//;
//
//BinaryExpression:
//	TerminalBinaryExpression ({Operation.left=current}
//		op= ('AND'|'OR') right = TerminalBinaryExpression)*
//;
//
//TerminalBinaryExpression returns BinaryExpression:
//	'(' Predicate ')'|
//	 {StateDefinition} instance = [StateDefinition]|
//	 {StateDefinition}(list ?= 'collectionOf' instance = [StateDefinition])
//;


TransitionComposition:
	'{'
		body = TransitionCompositionBody
	'}'
;

TransitionCompositionBody:
	'START' ('WITH' '(' startingInputs += [StateDefinition]+')')?
	'{'
		expression = InstructionExpression
	'}'
;

InstructionExpression:
	TerminalInstruction ({ExecutionResult.computeFirst = current} computeNext = TerminalInstruction)*
;

TerminalInstruction returns InstructionExpression:
	IfInstruction|
	WhileInstruction|
	SimpleInstruction|
	';'
;

IfInstruction:
	'IF' '(' testKey = ResolvableValue '==' testValue = TestValue ')' 
	'{'
		toComputeIfTrue = InstructionExpression
	'}' ('ELSE' '{'
		toComputeIfFalse = InstructionExpression
	'}')?
;

WhileInstruction:
	'WHILE''(' testKey = ResolvableValue '==' testValue = TestValue ')'
	'{'
		toCompute = InstructionExpression
	'}'
;

SimpleInstruction:
	'THEN' toExecute += [TransitionDefinition]+
;

//CompoundTransitionInstance:
//	'{'
//		body = CompoundTransitionInstanceBody
//	'}'
//;

CompoundTransitionInstanceBody:
	'START' ('WITH''('startingInputs += [Instance]+')')?
	'{'
		expression = InstanceInstructionExpression
	'}'
;

InstanceInstructionExpression:
	TerminalInstanceInstruction ({ExecutionResult.computeFirst = current} computeNext = TerminalInstanceInstruction)*
;


TerminalInstanceInstruction returns InstanceInstructionExpression:
	//'('InstructionExpression')' |
	IfInstanceInstruction |
	WhileInstanceInstruction|
	SimpleInstanceInstruction |
	';'
;

SimpleInstanceInstruction:
	 'THEN' toExecute += [Instance|STRING]+
;

IfInstanceInstruction:
	'IF' '(' testKey = ResolvableValue '==' testValue = TestValue ')' 
	'{'
		toComputeIfTrue = InstanceInstructionExpression
	'}' ('ELSE' '{'
		toComputeIfFalse = InstanceInstructionExpression
	'}')?
;



WhileInstanceInstruction:
	'WHILE''(' testKey = ResolvableValue '==' testValue = TestValue ')'
	'{'
		toCompute = InstanceInstructionExpression
	'}'
;

TestValue:
	 LiteralValue| ResolvableValue
;

LiteralValue:
	value = STRING
;

ResolvableValue:
	(ResolvableInstanceValue|ResolvableTransitionOutputValue)
;

ResolvableInstanceValue:
	instance = [Instance] '.' key = [StateDefinition]
;

ResolvableTransitionOutputValue:
	'OUTPUT' state = [StateDefinition] '.' key = [StateDefinition]
;

Term:
	Variable|Function
;

Variable:
	(key?=('$')? name = STATE_VARIABLE_NAME  state = [StateDefinition])|
	(key?=('$')? name = PRIMITIVE_VARIABLE_NAME type = PRIMITIVE_TYPES)
;

Function:
	(name = FUNCTION_NAME transition = [TransitionDefinition] '(' arguments += Argument* ')')|
	('->{@}' name = ID transition = [TransitionDefinition]'(' arguments += Argument*')')
;

Argument:
	term = [Term|TERM_NAME]
;

Formula:
	expression = Expression
;

Expression:
	Predicate|
	Equality|
	Negation|
	BinaryConnective|
	Quantifier
;

TerminalExpression returns Expression:
	'{'Expression'}'|
	{Expression}ExpressionValue
;

Predicate:
	'@' predicateState = [StateDefinition] '(' arguments += Argument* ')'
;

Equality:
	( left = [Term|TERM_NAME] operator = EqualityOperator right = [Term|TERM_NAME] )
;

Negation:
	'NOT' negatedFormula = TerminalExpression
;

BinaryConnective:
	leftFormula = TerminalExpression operator = LogicalOperator rightFormula = TerminalExpression 
;

Quantifier:
	(quantifier = 'forAll' variable = [Variable] 'thisHolds' formula = TerminalExpression)|
	(quantifier = 'thereExists' variable = [Variable] 'suchThat' formula = TerminalExpression ) 
;

LogicalOperator:
	IMPLIES|BICONDITION|LOGICAL_AND|LOGICAL_OR|LOGICAL_XOR
;

EqualityOperator:
	EQUAL|LESS_THAN|GREATER_THAN|LESS_THAN_OR_EQUAL|GREATER_THAN_OR_EQUAL
;

terminal EQUAL:
	'='
;

terminal  LESS_THAN:
	'<'
;

terminal GREATER_THAN:
	'>'
;

terminal LESS_THAN_OR_EQUAL:
	'<='
;

terminal GREATER_THAN_OR_EQUAL:
	'>='
;

terminal IMPLIES:
	'->'
;

terminal BICONDITION:
	'<->'
;

terminal LOGICAL_AND:
	'AND'
;

terminal LOGICAL_OR:
	'OR'
;

terminal LOGICAL_XOR:
	'XOR'
;

ExpressionValue:
	BOOLEAN|INT|STRING|CHARACTER
;


terminal CHARACTER:
	"'" ( '\\'('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") ) "'"
;



TERM_NAME:
	STATE_VARIABLE_NAME|PRIMITIVE_VARIABLE_NAME|FUNCTION_NAME
;

terminal STATE_VARIABLE_NAME:
	'*@' ID
;

terminal PRIMITIVE_VARIABLE_NAME:
	'!@' ID
;

terminal FUNCTION_NAME:
	'->@' ID
; 


