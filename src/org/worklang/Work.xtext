grammar org.worklang.Work with org.eclipse.xtext.common.Terminals

generate work "http://www.worklang.org/Work"


Model:
	fields += FieldDefinition*
	experts += Expert*
	practitioners += Practitioner*
	plans += Plan*
;

Plan:
	'plan' 
	name = ID '{'
	'produces' resultState = StateID
	'{'
	steps += Step+
	'}'
	'}'
;

Step:
	'step' stepNumber  = INT 
	stepTransition = ReferenceTransition
	'$' cost = INT
	'duration' duration = STRING
;

Practitioner:
	'practitioner''{'
	name = ID
	'knowledge''{'
	knowledge += ReferenceState
	'}'
	'skills''{'
	skills += ReferenceTransition
	'}'
	'}'
;

Expert:
	'expert'
	name = ID '{'
	refSpace = Referencespace
	'hourlyRate'
	'$' rate =  INT
	'}'
;
	

FieldDefinition:
	field = Field
	space = Space
	('extends' '[' namespaces += [Space]+ ']')? 
	'{'
	(conceptualspace = Namespace)?
	tangiblespace = Referencespace
	'}'	
;

Space:
	name = ID
//	space = Namespace | Referencespace
;

Namespace:
	spaceType = Definitions
	'{'
	states += StateObjectDefinition*
	transitions += TransitionObjectDefinition*
	'}'
;

Referencespace:
	spaceType = References
	'{'
	refStates += ReferenceState*
	refTransition += ReferenceTransition*
	'}'
;

StateObjectDefinition:
	(type = Primitive| type = Compound)
	state = StateDefinition 
;

TransitionObjectDefinition:
	(type = Primitive| type = Compound)
	transition = TransitionDefinition
;


StateDefinition:
	object = State ((state = StateID )| (state = StateID compoundStateDef = CompoundState))
;

StateID:
	 name = ID
;

CompoundState:
	'{'
	states += Predicate+	
	'}'
;

ReferenceState:
	object = State
 	refState = [StateID]
	from = FromDefinition 
	(('called'|'as')
		state = StateID)?
	('with' composition = CompoundState)?
	';'
;

TransitionDefinition:
	object = Transition ((transition = TransitionID in = InputDefinition out = OutputDefinition | 
		transition = TransitionID compoundTransitionDef = CompoundTransition))
;

TransitionID:
	name = ID
;

ReferenceTransition:
	object = Transition
	refTransition = [TransitionID]
	fromDef = FromDefinition
	(('called'|'as')
		transition = TransitionID)?
	('with' composition = CompoundTransition)?
	';'
;

FromDefinition:
	from = From
	refSpace = [Space]
;

InputDefinition:
	input = Input inputState = [StateID]
;

OutputDefinition:
	output = Output outputState = [StateID]
;

CompoundTransition:
	'{'
	subTransitions += Transition+
	'}'
;


Primitive:
	'primitive' 
;


Compound:
	'compound'
;

Field:
	'field'
;

State:
	'state'
;

Transition:
	'transition'
;

Definitions:
	'definitions'
;

References:
	'references'
;

Input:
	'input'
;

Output:
	'output'
;

From:
	'from'
;

Predicate:
	predicate = StateID | BooleanExpression ';'
;

BooleanExpression:
	(NotOp | BinaryOp) 
;

NotOp:
	'NOT' notState = [StateID]
;

BinaryOp:
	binaryOp = [StateID] ( andOp = AndOp| orOp = OrOp)
;

AndOp:
	'AND' andState = [StateID]
;

OrOp:
 	'OR' orState = [StateID]
;




