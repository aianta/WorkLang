/* 
 * 	Copyright 2018 Alexandru Ianta
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * 	Unless required by applicable law or agreed to in writing, software
 *	distributed under the License is distributed on an "AS IS" BASIS,
 *	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *	See the License for the specific language governing permissions and
 *	limitations under the License.
 * 
 */

grammar org.worklang.Work with org.eclipse.xtext.common.Terminals

generate work "http://www.worklang.org/Work"


Model:
	fields += FieldDefinition*
	experts += ExpertDefinition*
	practitioners += Practitioner*
	instructions += Instruction*
;

/* Executable Structure
 * Below are the grammar rules for defining execution requests for the work interpreter.
 */
Instruction:
	objectType = 'instruction' space = [Space] transition = [TransitionID]
;


UseDefinition:
	use = Use predefinedValue = [StateID] field = FromFieldDefinition
;


Practitioner:
	practitionerDef = 'practitioner'
	user = User
	'{'
	knowledgeDef = KnowledgeDefinition?
	skillsDef = SkillsDefinition?
	'}'
;

ExpertDefinition:
	expertDef = 'expert' user = User
	'{'
	domainDef = DomainDefinition?
	knowledgeDef = KnowledgeDefinition?
	skillsDef = SkillsDefinition?
	'hourlyRate'
	'$' rate =  INT
	'}'
;

User:
	name = ID
;
	

DomainDefinition:
	domain = 'domain'
	'{'
		domainAreas += ReferenceField*
	'}'
;

KnowledgeDefinition:
	knowledgeDef = 'knowledge''{'
		knowledge += ReferenceState*
	'}'
;

SkillsDefinition:
	skillsDef = 'skills''{'
		skills += ReferenceTransition*
	'}'
;


FieldDefinition:
	field = Field
	space = Space
	extends=(ExtendsDefinition)? 
	'{'
	(conceptualspace = Namespace)?
	(referencespace = Referencespace)?
	(instancespace = Instancespace)?
	'}'	
;

Space:
	name = ID
;

Namespace:
	spaceType = Definitions
	'{'
	states += StateObjectDefinition*
	transitions += TransitionObjectDefinition*
	'}'
;

Referencespace:
	spaceType = References
	'{'
	refFields += ReferenceField*
	refStates += ReferenceState*
	refTransition += ReferenceTransition*
	'}'
;

Instancespace:
	spaceType  = Instances
	'{'
		instances += Instance*
	'}'
;

ReferenceField:
	ref = Field 
	space = Space
;

StateObjectDefinition:
	(type = Primitive| type = Compound)
	state = StateDefinition 
;

TransitionObjectDefinition:
	(type = Primitive| type = Compound)
	transition = TransitionDefinition
;

PrimitiveStateDefinition:
	object = State id = StateID 
;

CompoundStateDefinition:
	object = State state = StateID (compoundStateDef= WithStatesDefinition)?
;

StateDefinition:
	object = State state = StateID (withDefinition= WithStatesDefinition)?
;


StateID:
	 name = ID
;

WithStatesDefinition:
	composition = With
	'{'
	predicate= Predicate
	'}'
;

WithTransitionsDefinition:
	composition = With
	'{'
	transitions = TransitionalExpression
	'}'
;

ReferenceState:
	object = State
 	refState = [StateID]
	from = FromFieldDefinition 
	(('called'|'as')
		state = StateID)?
	(composition = WithStatesDefinition)?
	
;

TransitionDefinition:
	object = Transition transition = TransitionID (in = InputDefinition)? out = OutputDefinition (composition = WithTransitionsDefinition)?
;

TransitionID:
	name = ID
;

ReferenceTransition:
	object = Transition
	refTransition = [TransitionID]
	fromDef = FromFieldDefinition
	(('called'|'as')
		transition = TransitionID)?
	(composition = WithTransitionsDefinition)?
	
;

FromFieldDefinition:
	from = From
	refSpace = [Space]
;


InputDefinition:
	input = Input inputState += [StateID]*
;

OutputDefinition:
	output = Output outputState = [StateID]
;

ExtendsDefinition:
	type = Extends
	namespaces += [Space]+	
;


Primitive:
	'primitive' 
;

Compound:
	'compound'
;

Field:
	'field'
;

State:
	'state'
;


Transition:
	'transition'
;

Definitions:
	'definitions'
;

References:
	'references'
;

Instances:
	'instances'
;

Input:
	'input'
;

Output:
	'output'
;

From:
	'from'
;

With:
	'with'
;

Extends:
	'extends'
;

NotOp:
	'NOT'
;

AndOp:
	'AND'
;

OrOp:
	'OR'
;

Set:
	'set'
;

To:
	'to'
;

Use:
	'use'
;


Count:
	INT
;

Instance:
	instanceDef = 'instance' 
	(transitionDeclaration = TransitionDeclaration| stateDeclaration = StateDeclaration) 
	name = STRING 
	(state = StateInstance | transition = TransitionInstance)
;

TransitionDeclaration:
	objectType = Transition transition = [TransitionID]
;

StateDeclaration:
	objectType = State state = [StateID]
;

TransitionInstance:
	host = STRING
	port = INT
	(path = STRING)?
;

StateInstance:
	 
	'{'
		members += (SetStatement| UseDefinition| Instance)+
	'}'
			
;

SetStatement:
	statement = Set variable = [StateID] toDef = ToDefinition
;

ToDefinition:
	to = To value = STRING
;

//State Composition Expression Rules
Predicate:
	(negation?=NotOp)? expression = BinaryExpression
;

BinaryExpression:
	TerminalBinaryExpression ({Operation.left=current}
		op= (AndOp|OrOp) right = TerminalBinaryExpression)*
;

TerminalBinaryExpression returns BinaryExpression:
	'(' Predicate ')'|
	 {StateID} instance = [StateID]|
	 {StateID}(list ?= 'setOf' value = [StateID])
;


//Transition Composition Expression Rules
TransitionalExpression:
	TerminalTransitionalExpression ({Operation.left=current}
		op= 'THEN' right = TerminalTransitionalExpression)*	
;

TerminalTransitionalExpression returns TransitionalExpression:
	'(' TransitionalExpression ')'|
	{TransitionID} value = [TransitionID]
;




