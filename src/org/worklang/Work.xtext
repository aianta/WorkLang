grammar org.worklang.Work with org.eclipse.xtext.common.Terminals

generate work "http://www.worklang.org/Work"


Model:
	fields += FieldDefinition*
	experts += Expert*
	practitioners += Practitioner*
	plans += PlanDefinition*
;

PlanDefinition:
	plan = Plan
	planId = PlanID'{'
	objective = ObjectiveDefinition
	solution = SolutionDefinition 
	'}'
;

PlanID:
	name = ID
;

ObjectiveDefinition:
	objective = Objective '{'
	(haves = HaveDefinition)
	(wants = WantDefinition)
	resolves = ResolveDefinition
	'}'
	
;

HaveDefinition:
	have = Have states += [StateID]+
;

WantDefinition:
	want = Want (states += [StateID]+ |
	novelState = StateDefinition)
;

UseDefinition:
	use = Use predefinedValue = [StateID] (field = FromFieldDefinition|step = FromStepDefinition)
;


SolutionDefinition:
	solution = Solution 
	'{'
	producesDef = ProducesDefinition 
	stepsDef = StepsDefinition
	'}'
;

StepsDefinition:
	steps = Steps '{'
		stepCollection += StepDefinition+
	'}'
;

ProducesDefinition:
	produces = Produces (result = [StateID] | novelResult = NovelStateDefinition)
;

NovelStateDefinition:
	novel = Novel stateName = StateID 
;

StepDefinition:
	step = Step name  = STRING 
	stepTransition = [TransitionID]
	(input = InstanceInputDefinition)?
	output = InstanceOutputDefinition
	cost = CostDefinition
	duration = DurationDefinition
;

DurationDefinition:
	duration = Duration time = STRING
;

CostDefinition:
	 cost = Cost value = CostValueDefinition
;

CostValueDefinition:
	 ('$' amount = INT| rate = 'hourlyRate')
;


Practitioner:
	'practitioner''{'
	name = ID
	'knowledge''{'
	knowledge += ReferenceState
	'}'
	'skills''{'
	skills += ReferenceTransition
	'}'
	'}'
;

Expert:
	'expert'
	name = ID '{'
	refSpace = Referencespace
	'hourlyRate'
	'$' rate =  INT
	'}'
;
	

FieldDefinition:
	field = Field
	space = Space
	extends=(ExtendsDefinition)? 
	'{'
	(conceptualspace = Namespace)?
	(tangiblespace = Referencespace)?
	'}'	
;

Space:
	name = ID
;

Namespace:
	spaceType = Definitions
	'{'
	states += StateObjectDefinition*
	transitions += TransitionObjectDefinition*
	'}'
;

Referencespace:
	spaceType = References
	'{'
	refStates += ReferenceState*
	refTransition += ReferenceTransition*
	'}'
;

StateObjectDefinition:
	(type = Primitive| type = Compound)
	state = StateDefinition 
;

TransitionObjectDefinition:
	(type = Primitive| type = Compound)
	transition = TransitionDefinition
;


StateDefinition:
	object = State state = StateID (compoundStateDef= WithStatesDefinition)?
;


StateID:
	 name = ID
;

WithStatesDefinition:
	composition = With
	'{'
	states= Predicate
	'}'
;

WithTransitionsDefinition:
	composition = With
	'{'
	transitions = TransitionalExpression
	'}'
;

ReferenceState:
	object = State
 	refState = [StateID]
	from = FromFieldDefinition 
	(('called'|'as')
		state = StateID)?
	(composition = WithStatesDefinition)?
	
;

TransitionDefinition:
	object = Transition transition = TransitionID (( in = InputDefinition out = OutputDefinition | 
		 compoundTransitionDef = WithTransitionsDefinition))
;

TransitionID:
	name = ID
;

ReferenceTransition:
	object = Transition
	refTransition = [TransitionID]
	fromDef = FromFieldDefinition
	(('called'|'as')
		transition = TransitionID)?
	(composition = WithTransitionsDefinition)?
	
;

FromFieldDefinition:
	from = From
	refSpace = [Space]
;

FromStepDefinition:
	from = From
	stepRef = StepReference
;

StepReference:
	step = Step refStep = [StepDefinition|STRING]
;

InputDefinition:
	input = Input inputState += [StateID]*
;

InstanceInputDefinition:
	input = Input '{' inputStates = StateInstance '}'
;

InstanceOutputDefinition:
	output = Output (outputState = [StateID] | novelOutputState = StateDefinition)
;

OutputDefinition:
	output = Output outputState = [StateID]
;

ObjectiveOutputDefinition:
	next = Next count = Count 'outputs'
;

ExtendsDefinition:
	type = Extends
	namespaces += [Space]+	
;

ResolveDefinition:
	(resolve = Resolve (resolveInputs = 'inputs'| resolveOutputs = ObjectiveOutputDefinition))
;

Primitive:
	'primitive' 
;

Next:
	'next'
;

Compound:
	'compound'
;

Field:
	'field'
;

State:
	'state'
;

Step:
	'step'
;

Transition:
	'transition'
;

Definitions:
	'definitions'
;

References:
	'references'
;

Input:
	'input'
;

Output:
	'output'
;

From:
	'from'
;

With:
	'with'
;

Extends:
	'extends'
;

NotOp:
	'NOT'
;

AndOp:
	'AND'
;

OrOp:
	'OR'
;

Set:
	'set'
;

To:
	'to'
;

Use:
	'use'
;

Solution:
	'solution'
;

Objective:
	'objective'
;

Have:
	'have'
;

Want:
	'want'
;

Resolve:
	'resolve'
;

Plan:
	'plan'
;

Count:
	INT
;

Produces:
	'produces'
;

Novel:
	'novel'
;

Steps:
	'steps'
;

Cost:
	'cost'
;

Duration:
	'duration'
;

StateInstance: 
		substate = TerminalStateInstance ({Operation.left = current}
			right = TerminalStateInstance)*	
;

TerminalStateInstance returns StateInstance:
	substateId = [StateID] '{'instance = StateInstance'}' |
	set = Set variable = [StateID] toDef = ToDefinition  |
	UseDefinition
;

ToDefinition:
	to = To value = STRING
;

//State Composition Expression Rules
Predicate:
	(negation?=NotOp)? expression = BinaryExpression
;

BinaryExpression:
	TerminalBinaryExpression ({Operation.left=current}
		op= (AndOp|OrOp) right = TerminalBinaryExpression)*
;

TerminalBinaryExpression returns BinaryExpression:
	'(' Predicate ')'|
	 {StateID} value = [StateID]
;


//Transition Composition Expression Rules
TransitionalExpression:
	TerminalTransitionalExpression ({Operation.left=current}
		op= 'THEN' right = TerminalTransitionalExpression)*	
;

TerminalTransitionalExpression returns TransitionalExpression:
	'(' TransitionalExpression ')'|
	{TransitionID} value = [TransitionID]
;

